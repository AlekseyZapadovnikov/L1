package main

import (
	"fmt"
)

func main() {
	// просим пользователя ввести данные
	var n, bit, oneOrZero, mask, ans int64
	fmt.Println("введите исходное число")
	_, err := fmt.Scan(&n)
	if err != nil {
		fmt.Println("Ошибка ввода:", err)
		return
	}
	fmt.Println("введите бит, который нужно поменять (0-63)")
	_, err = fmt.Scan(&bit)
	if err != nil {
		fmt.Println("Ошибка ввода:", err)
		return
	}
	fmt.Printf("введите на какой бит вы хотите поменть %v бит (0 или 1)\n", bit)
	_, err = fmt.Scan(&oneOrZero)
	if err != nil {
		fmt.Println("Ошибка ввода:", err)
		return
	}

	// меняем нужный бит
	// если нужно установить 0, то создаём маску с 0 на нужном бите и 1 на остальных
	// если нужно установить 1, то создаём маску с 1 на нужном бите и 0 на остальных
	// потом применяем побитовое ИЛИ или И соответственно
	mask = 1
	if oneOrZero == 0 {
		mask = 1
		r := 63 - int(bit)
		// заполняем все биты 1 справа от того, который мы хотим поменять

		// пишем 1, которые будут слева от нашего бита
		for i := 0; i < r; i++ {
			mask = (mask<<1) + 1
		}
		mask <<= 1 // сдвигаем маску влево, чтобы освободить место для бита который мы хотим поменять

		// пишем 1, которые будут справа от нашего бита
		for i := 0; i < int(bit); i++ {
			mask = (mask << 1) + 1
		}
		ans = n & int64(mask) // побитовое и с нашей масской (0 на нужном бите, 1 на остальных)
	} else {
		// хотим получить маску 0000010000... где 1 на нужном бите
		for i := 0; i < int(bit); i++ {
			mask = (mask<<1)
		}
		ans = n | mask // побитовое или с нашей масской (1 на нужном бите, 0 на остальных)
	}

	fmt.Println("Ответ:", ans)
}